{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/sabrinabongiovanni/my-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/sabrinabongiovanni/my-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _get = require(\"/Users/sabrinabongiovanni/my-app/node_modules/@babel/runtime/helpers/get.js\").default;\n\nvar _getPrototypeOf = require(\"/Users/sabrinabongiovanni/my-app/node_modules/@babel/runtime/helpers/getPrototypeOf.js\").default;\n\nvar _inherits = require(\"/Users/sabrinabongiovanni/my-app/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Users/sabrinabongiovanni/my-app/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar XHTMLEntities = require('./xhtml');\n\nvar hexNumber = /^[\\da-fA-F]+$/;\nvar decimalNumber = /^\\d+$/; // The map to `acorn-jsx` tokens from `acorn` namespace objects.\n\nvar acornJsxMap = new WeakMap(); // Get the original tokens for the given `acorn` namespace object.\n\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  var acornJsx = acornJsxMap.get(acorn);\n\n  if (!acornJsx) {\n    var tt = acorn.tokTypes;\n    var TokContext = acorn.TokContext;\n    var TokenType = acorn.TokenType;\n    var tc_oTag = new TokContext('<tag', false);\n    var tc_cTag = new TokContext('</tag', false);\n    var tc_expr = new TokContext('<tag>...</tag>', true, true);\n    var tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    var tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {\n        beforeExpr: true\n      }),\n      jsxTagStart: new TokenType('jsxTagStart', {\n        startsExpr: true\n      }),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function () {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n\n      this.context.push(tc_oTag); // start opening tag context\n\n      this.exprAllowed = false;\n    };\n\n    tokTypes.jsxTagEnd.updateContext = function (prevType) {\n      var out = this.context.pop();\n\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = {\n      tokContexts: tokContexts,\n      tokTypes: tokTypes\n    };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n} // Transforms JSX element name to string.\n\n\nfunction getQualifiedJSXName(object) {\n  if (!object) return object;\n  if (object.type === 'JSXIdentifier') return object.name;\n  if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;\n  if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function (options) {\n  options = options || {};\n  return function (Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n}; // This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\n\n\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  var acorn = Parser.acorn || require(\"acorn\");\n\n  var acornJsx = getJsxTokens(acorn);\n  var tt = acorn.tokTypes;\n  var tok = acornJsx.tokTypes;\n  var tokContexts = acorn.tokContexts;\n  var tc_oTag = acornJsx.tokContexts.tc_oTag;\n  var tc_cTag = acornJsx.tokContexts.tc_cTag;\n  var tc_expr = acornJsx.tokContexts.tc_expr;\n  var isNewLine = acorn.isNewLine;\n  var isIdentifierStart = acorn.isIdentifierStart;\n  var isIdentifierChar = acorn.isIdentifierChar;\n  return /*#__PURE__*/function (_Parser) {\n    _inherits(_class, _Parser);\n\n    var _super = _createSuper(_class);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(_class, [{\n      key: \"jsx_readToken\",\n      value: // Reads inline JSX contents token.\n      function jsx_readToken() {\n        var out = '',\n            chunkStart = this.pos;\n\n        for (;;) {\n          if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');\n          var ch = this.input.charCodeAt(this.pos);\n\n          switch (ch) {\n            case 60: // '<'\n\n            case 123:\n              // '{'\n              if (this.pos === this.start) {\n                if (ch === 60 && this.exprAllowed) {\n                  ++this.pos;\n                  return this.finishToken(tok.jsxTagStart);\n                }\n\n                return this.getTokenFromCode(ch);\n              }\n\n              out += this.input.slice(chunkStart, this.pos);\n              return this.finishToken(tok.jsxText, out);\n\n            case 38:\n              // '&'\n              out += this.input.slice(chunkStart, this.pos);\n              out += this.jsx_readEntity();\n              chunkStart = this.pos;\n              break;\n\n            case 62: // '>'\n\n            case 125:\n              // '}'\n              this.raise(this.pos, \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" + (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\");\n\n            default:\n              if (isNewLine(ch)) {\n                out += this.input.slice(chunkStart, this.pos);\n                out += this.jsx_readNewLine(true);\n                chunkStart = this.pos;\n              } else {\n                ++this.pos;\n              }\n\n          }\n        }\n      }\n    }, {\n      key: \"jsx_readNewLine\",\n      value: function jsx_readNewLine(normalizeCRLF) {\n        var ch = this.input.charCodeAt(this.pos);\n        var out;\n        ++this.pos;\n\n        if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n          ++this.pos;\n          out = normalizeCRLF ? '\\n' : '\\r\\n';\n        } else {\n          out = String.fromCharCode(ch);\n        }\n\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n\n        return out;\n      }\n    }, {\n      key: \"jsx_readString\",\n      value: function jsx_readString(quote) {\n        var out = '',\n            chunkStart = ++this.pos;\n\n        for (;;) {\n          if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');\n          var ch = this.input.charCodeAt(this.pos);\n          if (ch === quote) break;\n\n          if (ch === 38) {\n            // '&'\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readEntity();\n            chunkStart = this.pos;\n          } else if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(false);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.pos++);\n        return this.finishToken(tt.string, out);\n      }\n    }, {\n      key: \"jsx_readEntity\",\n      value: function jsx_readEntity() {\n        var str = '',\n            count = 0,\n            entity;\n        var ch = this.input[this.pos];\n        if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');\n        var startPos = ++this.pos;\n\n        while (this.pos < this.input.length && count++ < 10) {\n          ch = this.input[this.pos++];\n\n          if (ch === ';') {\n            if (str[0] === '#') {\n              if (str[1] === 'x') {\n                str = str.substr(2);\n                if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));\n              } else {\n                str = str.substr(1);\n                if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));\n              }\n            } else {\n              entity = XHTMLEntities[str];\n            }\n\n            break;\n          }\n\n          str += ch;\n        }\n\n        if (!entity) {\n          this.pos = startPos;\n          return '&';\n        }\n\n        return entity;\n      } // Read a JSX identifier (valid tag or attribute name).\n      //\n      // Optimized version since JSX identifiers can't contain\n      // escape characters and so can be read as single slice.\n      // Also assumes that first character was already checked\n      // by isIdentifierStart in readToken.\n\n    }, {\n      key: \"jsx_readWord\",\n      value: function jsx_readWord() {\n        var ch,\n            start = this.pos;\n\n        do {\n          ch = this.input.charCodeAt(++this.pos);\n        } while (isIdentifierChar(ch) || ch === 45); // '-'\n\n\n        return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n      } // Parse next token as JSX identifier\n\n    }, {\n      key: \"jsx_parseIdentifier\",\n      value: function jsx_parseIdentifier() {\n        var node = this.startNode();\n        if (this.type === tok.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();\n        this.next();\n        return this.finishNode(node, 'JSXIdentifier');\n      } // Parse namespaced identifier.\n\n    }, {\n      key: \"jsx_parseNamespacedName\",\n      value: function jsx_parseNamespacedName() {\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var name = this.jsx_parseIdentifier();\n        if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n        var node = this.startNodeAt(startPos, startLoc);\n        node.namespace = name;\n        node.name = this.jsx_parseIdentifier();\n        return this.finishNode(node, 'JSXNamespacedName');\n      } // Parses element name in any form - namespaced, member\n      // or single identifier.\n\n    }, {\n      key: \"jsx_parseElementName\",\n      value: function jsx_parseElementName() {\n        if (this.type === tok.jsxTagEnd) return '';\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var node = this.jsx_parseNamespacedName();\n\n        if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n          this.unexpected();\n        }\n\n        while (this.eat(tt.dot)) {\n          var newNode = this.startNodeAt(startPos, startLoc);\n          newNode.object = node;\n          newNode.property = this.jsx_parseIdentifier();\n          node = this.finishNode(newNode, 'JSXMemberExpression');\n        }\n\n        return node;\n      } // Parses any type of JSX attribute value.\n\n    }, {\n      key: \"jsx_parseAttributeValue\",\n      value: function jsx_parseAttributeValue() {\n        switch (this.type) {\n          case tt.braceL:\n            var node = this.jsx_parseExpressionContainer();\n            if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n            return node;\n\n          case tok.jsxTagStart:\n          case tt.string:\n            return this.parseExprAtom();\n\n          default:\n            this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n        }\n      } // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n      // and so it should start at the end of last read token (left brace) and finish\n      // at the beginning of the next one (right brace).\n\n    }, {\n      key: \"jsx_parseEmptyExpression\",\n      value: function jsx_parseEmptyExpression() {\n        var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n        return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n      } // Parses JSX expression enclosed into curly brackets.\n\n    }, {\n      key: \"jsx_parseExpressionContainer\",\n      value: function jsx_parseExpressionContainer() {\n        var node = this.startNode();\n        this.next();\n        node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXExpressionContainer');\n      } // Parses following JSX attribute name-value pair.\n\n    }, {\n      key: \"jsx_parseAttribute\",\n      value: function jsx_parseAttribute() {\n        var node = this.startNode();\n\n        if (this.eat(tt.braceL)) {\n          this.expect(tt.ellipsis);\n          node.argument = this.parseMaybeAssign();\n          this.expect(tt.braceR);\n          return this.finishNode(node, 'JSXSpreadAttribute');\n        }\n\n        node.name = this.jsx_parseNamespacedName();\n        node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n        return this.finishNode(node, 'JSXAttribute');\n      } // Parses JSX opening tag starting after '<'.\n\n    }, {\n      key: \"jsx_parseOpeningElementAt\",\n      value: function jsx_parseOpeningElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.attributes = [];\n        var nodeName = this.jsx_parseElementName();\n        if (nodeName) node.name = nodeName;\n\n        while (this.type !== tt.slash && this.type !== tok.jsxTagEnd) {\n          node.attributes.push(this.jsx_parseAttribute());\n        }\n\n        node.selfClosing = this.eat(tt.slash);\n        this.expect(tok.jsxTagEnd);\n        return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n      } // Parses JSX closing tag starting after '</'.\n\n    }, {\n      key: \"jsx_parseClosingElementAt\",\n      value: function jsx_parseClosingElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n        var nodeName = this.jsx_parseElementName();\n        if (nodeName) node.name = nodeName;\n        this.expect(tok.jsxTagEnd);\n        return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n      } // Parses entire JSX element, including it's opening tag\n      // (starting after '<'), attributes, contents and closing tag.\n\n    }, {\n      key: \"jsx_parseElementAt\",\n      value: function jsx_parseElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n        var children = [];\n        var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n        var closingElement = null;\n\n        if (!openingElement.selfClosing) {\n          contents: for (;;) {\n            switch (this.type) {\n              case tok.jsxTagStart:\n                startPos = this.start;\n                startLoc = this.startLoc;\n                this.next();\n\n                if (this.eat(tt.slash)) {\n                  closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n                  break contents;\n                }\n\n                children.push(this.jsx_parseElementAt(startPos, startLoc));\n                break;\n\n              case tok.jsxText:\n                children.push(this.parseExprAtom());\n                break;\n\n              case tt.braceL:\n                children.push(this.jsx_parseExpressionContainer());\n                break;\n\n              default:\n                this.unexpected();\n            }\n          }\n\n          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n            this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n          }\n        }\n\n        var fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n        node['opening' + fragmentOrElement] = openingElement;\n        node['closing' + fragmentOrElement] = closingElement;\n        node.children = children;\n\n        if (this.type === tt.relational && this.value === \"<\") {\n          this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n        }\n\n        return this.finishNode(node, 'JSX' + fragmentOrElement);\n      } // Parse JSX text\n\n    }, {\n      key: \"jsx_parseText\",\n      value: function jsx_parseText() {\n        var node = this.parseLiteral(this.value);\n        node.type = \"JSXText\";\n        return node;\n      } // Parses entire JSX element from current position.\n\n    }, {\n      key: \"jsx_parseElement\",\n      value: function jsx_parseElement() {\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        this.next();\n        return this.jsx_parseElementAt(startPos, startLoc);\n      }\n    }, {\n      key: \"parseExprAtom\",\n      value: function parseExprAtom(refShortHandDefaultPos) {\n        if (this.type === tok.jsxText) return this.jsx_parseText();else if (this.type === tok.jsxTagStart) return this.jsx_parseElement();else return _get(_getPrototypeOf(_class.prototype), \"parseExprAtom\", this).call(this, refShortHandDefaultPos);\n      }\n    }, {\n      key: \"readToken\",\n      value: function readToken(code) {\n        var context = this.curContext();\n        if (context === tc_expr) return this.jsx_readToken();\n\n        if (context === tc_oTag || context === tc_cTag) {\n          if (isIdentifierStart(code)) return this.jsx_readWord();\n\n          if (code == 62) {\n            ++this.pos;\n            return this.finishToken(tok.jsxTagEnd);\n          }\n\n          if ((code === 34 || code === 39) && context == tc_oTag) return this.jsx_readString(code);\n        }\n\n        if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagStart);\n        }\n\n        return _get(_getPrototypeOf(_class.prototype), \"readToken\", this).call(this, code);\n      }\n    }, {\n      key: \"updateContext\",\n      value: function updateContext(prevType) {\n        if (this.type == tt.braceL) {\n          var curContext = this.curContext();\n          if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);else _get(_getPrototypeOf(_class.prototype), \"updateContext\", this).call(this, prevType);\n          this.exprAllowed = true;\n        } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n\n          this.context.push(tc_cTag); // reconsider as closing tag context\n\n          this.exprAllowed = false;\n        } else {\n          return _get(_getPrototypeOf(_class.prototype), \"updateContext\", this).call(this, prevType);\n        }\n      }\n    }], [{\n      key: \"acornJsx\",\n      get: // Expose actual `tokTypes` and `tokContexts` to other plugins.\n      function get() {\n        return acornJsx;\n      }\n    }]);\n\n    return _class;\n  }(Parser);\n}","map":{"version":3,"names":["XHTMLEntities","require","hexNumber","decimalNumber","acornJsxMap","WeakMap","getJsxTokens","acorn","Parser","acornJsx","get","tt","tokTypes","TokContext","TokenType","tc_oTag","tc_cTag","tc_expr","tokContexts","jsxName","jsxText","beforeExpr","jsxTagStart","startsExpr","jsxTagEnd","updateContext","context","push","exprAllowed","prevType","out","pop","slash","curContext","set","getQualifiedJSXName","object","type","name","namespace","property","module","exports","options","plugin","allowNamespaces","allowNamespacedObjects","Object","defineProperty","get_tokTypes","configurable","enumerable","tok","isNewLine","isIdentifierStart","isIdentifierChar","chunkStart","pos","input","length","raise","start","ch","charCodeAt","finishToken","getTokenFromCode","slice","jsx_readEntity","jsx_readNewLine","normalizeCRLF","String","fromCharCode","locations","curLine","lineStart","quote","string","str","count","entity","startPos","substr","test","parseInt","node","startNode","value","keyword","unexpected","next","finishNode","startLoc","jsx_parseIdentifier","eat","colon","startNodeAt","jsx_parseNamespacedName","dot","newNode","braceL","jsx_parseExpressionContainer","expression","parseExprAtom","lastTokEnd","lastTokEndLoc","finishNodeAt","braceR","jsx_parseEmptyExpression","parseExpression","expect","ellipsis","argument","parseMaybeAssign","eq","jsx_parseAttributeValue","attributes","nodeName","jsx_parseElementName","jsx_parseAttribute","selfClosing","children","openingElement","jsx_parseOpeningElementAt","closingElement","contents","jsx_parseClosingElementAt","jsx_parseElementAt","fragmentOrElement","relational","parseLiteral","refShortHandDefaultPos","jsx_parseText","jsx_parseElement","code","jsx_readToken","jsx_readWord","jsx_readString","b_expr","b_tmpl"],"sources":["/Users/sabrinabongiovanni/my-app/node_modules/buble/node_modules/acorn-jsx/index.js"],"sourcesContent":["'use strict';\n\nconst XHTMLEntities = require('./xhtml');\n\nconst hexNumber = /^[\\da-fA-F]+$/;\nconst decimalNumber = /^\\d+$/;\n\n// The map to `acorn-jsx` tokens from `acorn` namespace objects.\nconst acornJsxMap = new WeakMap();\n\n// Get the original tokens for the given `acorn` namespace object.\nfunction getJsxTokens(acorn) {\n  acorn = acorn.Parser.acorn || acorn;\n  let acornJsx = acornJsxMap.get(acorn);\n  if (!acornJsx) {\n    const tt = acorn.tokTypes;\n    const TokContext = acorn.TokContext;\n    const TokenType = acorn.TokenType;\n    const tc_oTag = new TokContext('<tag', false);\n    const tc_cTag = new TokContext('</tag', false);\n    const tc_expr = new TokContext('<tag>...</tag>', true, true);\n    const tokContexts = {\n      tc_oTag: tc_oTag,\n      tc_cTag: tc_cTag,\n      tc_expr: tc_expr\n    };\n    const tokTypes = {\n      jsxName: new TokenType('jsxName'),\n      jsxText: new TokenType('jsxText', {beforeExpr: true}),\n      jsxTagStart: new TokenType('jsxTagStart', {startsExpr: true}),\n      jsxTagEnd: new TokenType('jsxTagEnd')\n    };\n\n    tokTypes.jsxTagStart.updateContext = function() {\n      this.context.push(tc_expr); // treat as beginning of JSX expression\n      this.context.push(tc_oTag); // start opening tag context\n      this.exprAllowed = false;\n    };\n    tokTypes.jsxTagEnd.updateContext = function(prevType) {\n      let out = this.context.pop();\n      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {\n        this.context.pop();\n        this.exprAllowed = this.curContext() === tc_expr;\n      } else {\n        this.exprAllowed = true;\n      }\n    };\n\n    acornJsx = { tokContexts: tokContexts, tokTypes: tokTypes };\n    acornJsxMap.set(acorn, acornJsx);\n  }\n\n  return acornJsx;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(object) {\n  if (!object)\n    return object;\n\n  if (object.type === 'JSXIdentifier')\n    return object.name;\n\n  if (object.type === 'JSXNamespacedName')\n    return object.namespace.name + ':' + object.name.name;\n\n  if (object.type === 'JSXMemberExpression')\n    return getQualifiedJSXName(object.object) + '.' +\n    getQualifiedJSXName(object.property);\n}\n\nmodule.exports = function(options) {\n  options = options || {};\n  return function(Parser) {\n    return plugin({\n      allowNamespaces: options.allowNamespaces !== false,\n      allowNamespacedObjects: !!options.allowNamespacedObjects\n    }, Parser);\n  };\n};\n\n// This is `tokTypes` of the peer dep.\n// This can be different instances from the actual `tokTypes` this plugin uses.\nObject.defineProperty(module.exports, \"tokTypes\", {\n  get: function get_tokTypes() {\n    return getJsxTokens(require(\"acorn\")).tokTypes;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nfunction plugin(options, Parser) {\n  const acorn = Parser.acorn || require(\"acorn\");\n  const acornJsx = getJsxTokens(acorn);\n  const tt = acorn.tokTypes;\n  const tok = acornJsx.tokTypes;\n  const tokContexts = acorn.tokContexts;\n  const tc_oTag = acornJsx.tokContexts.tc_oTag;\n  const tc_cTag = acornJsx.tokContexts.tc_cTag;\n  const tc_expr = acornJsx.tokContexts.tc_expr;\n  const isNewLine = acorn.isNewLine;\n  const isIdentifierStart = acorn.isIdentifierStart;\n  const isIdentifierChar = acorn.isIdentifierChar;\n\n  return class extends Parser {\n    // Expose actual `tokTypes` and `tokContexts` to other plugins.\n    static get acornJsx() {\n      return acornJsx;\n    }\n\n    // Reads inline JSX contents token.\n    jsx_readToken() {\n      let out = '', chunkStart = this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated JSX contents');\n        let ch = this.input.charCodeAt(this.pos);\n\n        switch (ch) {\n        case 60: // '<'\n        case 123: // '{'\n          if (this.pos === this.start) {\n            if (ch === 60 && this.exprAllowed) {\n              ++this.pos;\n              return this.finishToken(tok.jsxTagStart);\n            }\n            return this.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.pos);\n          return this.finishToken(tok.jsxText, out);\n\n        case 38: // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n          break;\n\n        case 62: // '>'\n        case 125: // '}'\n          this.raise(\n            this.pos,\n            \"Unexpected token `\" + this.input[this.pos] + \"`. Did you mean `\" +\n              (ch === 62 ? \"&gt;\" : \"&rbrace;\") + \"` or \" + \"`{\\\"\" + this.input[this.pos] + \"\\\"}\" + \"`?\"\n          );\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.jsx_readNewLine(true);\n            chunkStart = this.pos;\n          } else {\n            ++this.pos;\n          }\n        }\n      }\n    }\n\n    jsx_readNewLine(normalizeCRLF) {\n      let ch = this.input.charCodeAt(this.pos);\n      let out;\n      ++this.pos;\n      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n        out = normalizeCRLF ? '\\n' : '\\r\\n';\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n\n      return out;\n    }\n\n    jsx_readString(quote) {\n      let out = '', chunkStart = ++this.pos;\n      for (;;) {\n        if (this.pos >= this.input.length)\n          this.raise(this.start, 'Unterminated string constant');\n        let ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 38) { // '&'\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readEntity();\n          chunkStart = this.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.pos);\n          out += this.jsx_readNewLine(false);\n          chunkStart = this.pos;\n        } else {\n          ++this.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsx_readEntity() {\n      let str = '', count = 0, entity;\n      let ch = this.input[this.pos];\n      if (ch !== '&')\n        this.raise(this.pos, 'Entity must start with an ampersand');\n      let startPos = ++this.pos;\n      while (this.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.pos++];\n        if (ch === ';') {\n          if (str[0] === '#') {\n            if (str[1] === 'x') {\n              str = str.substr(2);\n              if (hexNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 16));\n            } else {\n              str = str.substr(1);\n              if (decimalNumber.test(str))\n                entity = String.fromCharCode(parseInt(str, 10));\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.pos = startPos;\n        return '&';\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can't contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsx_readWord() {\n      let ch, start = this.pos;\n      do {\n        ch = this.input.charCodeAt(++this.pos);\n      } while (isIdentifierChar(ch) || ch === 45); // '-'\n      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsx_parseIdentifier() {\n      let node = this.startNode();\n      if (this.type === tok.jsxName)\n        node.name = this.value;\n      else if (this.type.keyword)\n        node.name = this.type.keyword;\n      else\n        this.unexpected();\n      this.next();\n      return this.finishNode(node, 'JSXIdentifier');\n    }\n\n    // Parse namespaced identifier.\n\n    jsx_parseNamespacedName() {\n      let startPos = this.start, startLoc = this.startLoc;\n      let name = this.jsx_parseIdentifier();\n      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsx_parseIdentifier();\n      return this.finishNode(node, 'JSXNamespacedName');\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsx_parseElementName() {\n      if (this.type === tok.jsxTagEnd) return '';\n      let startPos = this.start, startLoc = this.startLoc;\n      let node = this.jsx_parseNamespacedName();\n      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) {\n        this.unexpected();\n      }\n      while (this.eat(tt.dot)) {\n        let newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsx_parseIdentifier();\n        node = this.finishNode(newNode, 'JSXMemberExpression');\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsx_parseAttributeValue() {\n      switch (this.type) {\n      case tt.braceL:\n        let node = this.jsx_parseExpressionContainer();\n        if (node.expression.type === 'JSXEmptyExpression')\n          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');\n        return node;\n\n      case tok.jsxTagStart:\n      case tt.string:\n        return this.parseExprAtom();\n\n      default:\n        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsx_parseEmptyExpression() {\n      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);\n      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsx_parseExpressionContainer() {\n      let node = this.startNode();\n      this.next();\n      node.expression = this.type === tt.braceR\n        ? this.jsx_parseEmptyExpression()\n        : this.parseExpression();\n      this.expect(tt.braceR);\n      return this.finishNode(node, 'JSXExpressionContainer');\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsx_parseAttribute() {\n      let node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(tt.braceR);\n        return this.finishNode(node, 'JSXSpreadAttribute');\n      }\n      node.name = this.jsx_parseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;\n      return this.finishNode(node, 'JSXAttribute');\n    }\n\n    // Parses JSX opening tag starting after '<'.\n\n    jsx_parseOpeningElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      node.attributes = [];\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)\n        node.attributes.push(this.jsx_parseAttribute());\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');\n    }\n\n    // Parses JSX closing tag starting after '</'.\n\n    jsx_parseClosingElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let nodeName = this.jsx_parseElementName();\n      if (nodeName) node.name = nodeName;\n      this.expect(tok.jsxTagEnd);\n      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');\n    }\n\n    // Parses entire JSX element, including it's opening tag\n    // (starting after '<'), attributes, contents and closing tag.\n\n    jsx_parseElementAt(startPos, startLoc) {\n      let node = this.startNodeAt(startPos, startLoc);\n      let children = [];\n      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.type) {\n          case tok.jsxTagStart:\n            startPos = this.start; startLoc = this.startLoc;\n            this.next();\n            if (this.eat(tt.slash)) {\n              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n            children.push(this.jsx_parseElementAt(startPos, startLoc));\n            break;\n\n          case tok.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case tt.braceL:\n            children.push(this.jsx_parseExpressionContainer());\n            break;\n\n          default:\n            this.unexpected();\n          }\n        }\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(\n            closingElement.start,\n            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');\n        }\n      }\n      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';\n\n      node['opening' + fragmentOrElement] = openingElement;\n      node['closing' + fragmentOrElement] = closingElement;\n      node.children = children;\n      if (this.type === tt.relational && this.value === \"<\") {\n        this.raise(this.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n      }\n      return this.finishNode(node, 'JSX' + fragmentOrElement);\n    }\n\n    // Parse JSX text\n\n    jsx_parseText() {\n      let node = this.parseLiteral(this.value);\n      node.type = \"JSXText\";\n      return node;\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsx_parseElement() {\n      let startPos = this.start, startLoc = this.startLoc;\n      this.next();\n      return this.jsx_parseElementAt(startPos, startLoc);\n    }\n\n    parseExprAtom(refShortHandDefaultPos) {\n      if (this.type === tok.jsxText)\n        return this.jsx_parseText();\n      else if (this.type === tok.jsxTagStart)\n        return this.jsx_parseElement();\n      else\n        return super.parseExprAtom(refShortHandDefaultPos);\n    }\n\n    readToken(code) {\n      let context = this.curContext();\n\n      if (context === tc_expr) return this.jsx_readToken();\n\n      if (context === tc_oTag || context === tc_cTag) {\n        if (isIdentifierStart(code)) return this.jsx_readWord();\n\n        if (code == 62) {\n          ++this.pos;\n          return this.finishToken(tok.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context == tc_oTag)\n          return this.jsx_readString(code);\n      }\n\n      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {\n        ++this.pos;\n        return this.finishToken(tok.jsxTagStart);\n      }\n      return super.readToken(code);\n    }\n\n    updateContext(prevType) {\n      if (this.type == tt.braceL) {\n        var curContext = this.curContext();\n        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);\n        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);\n        else super.updateContext(prevType);\n        this.exprAllowed = true;\n      } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {\n        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.context.push(tc_cTag); // reconsider as closing tag context\n        this.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}