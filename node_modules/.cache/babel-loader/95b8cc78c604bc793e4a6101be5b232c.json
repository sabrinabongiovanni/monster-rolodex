{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/sabrinabongiovanni/my-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar generate = require('regjsgen').generate;\n\nvar parse = require('regjsparser').parse;\n\nvar regenerate = require('regenerate');\n\nvar unicodeMatchProperty = require('unicode-match-property-ecmascript');\n\nvar unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\n\nvar iuMappings = require('./data/iu-mappings.js');\n\nvar ESCAPE_SETS = require('./data/character-class-escape-sets.js'); // Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\n\n\nvar UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF); // Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\n\nvar BMP_SET = regenerate().addRange(0x0, 0xFFFF); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\n\nvar DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove( // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A, // Line Feed <LF>\n0x000D, // Carriage Return <CR>\n0x2028, // Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./` (only BMP code points).\n\nvar DOT_SET = DOT_SET_UNICODE.clone().intersection(BMP_SET);\n\nvar getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n\n  return ESCAPE_SETS.REGULAR.get(character);\n};\n\nvar getDotSet = function getDotSet(unicode, dotAll) {\n  if (dotAll) {\n    return unicode ? UNICODE_SET : BMP_SET;\n  }\n\n  return unicode ? DOT_SET_UNICODE : DOT_SET;\n};\n\nvar getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {\n  var path = value ? \"\".concat(property, \"/\").concat(value) : \"Binary_Property/\".concat(property);\n\n  try {\n    return require(\"regenerate-unicode-properties/\".concat(path, \".js\"));\n  } catch (exception) {\n    throw new Error(\"Failed to recognize value `\".concat(value, \"` for property \") + \"`\".concat(property, \"`.\"));\n  }\n};\n\nvar handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    var _property = 'General_Category';\n    var category = unicodeMatchPropertyValue(_property, value);\n    return getUnicodePropertyValueSet(_property, category);\n  } catch (exception) {} // It’s not a `General_Category` value, so check if it’s a binary\n  // property. Note: `unicodeMatchProperty` throws on invalid properties.\n\n\n  var property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\n\nvar getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {\n  var parts = value.split('=');\n  var firstPart = parts[0];\n  var set;\n\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    var property = unicodeMatchProperty(firstPart);\n\n    var _value = unicodeMatchPropertyValue(property, parts[1]);\n\n    set = getUnicodePropertyValueSet(property, _value);\n  }\n\n  if (isNegative) {\n    return UNICODE_SET.clone().remove(set);\n  }\n\n  return set.clone();\n}; // Given a range of code points, add any case-folded code points in that range\n// to a set.\n\n\nregenerate.prototype.iuAddRange = function (min, max) {\n  var $this = this;\n\n  do {\n    var folded = caseFold(min);\n\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n\n  return $this;\n};\n\nvar update = function update(item, pattern) {\n  var tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n\n  Object.assign(item, tree);\n};\n\nvar wrap = function wrap(tree, pattern) {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': \"(?:\".concat(pattern, \")\")\n  };\n};\n\nvar caseFold = function caseFold(codePoint) {\n  return iuMappings.get(codePoint) || false;\n};\n\nvar processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {\n  var set = regenerate();\n\n  var _iterator = _createForOfIteratorHelper(characterClassItem.body),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n\n      switch (item.type) {\n        case 'value':\n          set.add(item.codePoint);\n\n          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n            var folded = caseFold(item.codePoint);\n\n            if (folded) {\n              set.add(folded);\n            }\n          }\n\n          break;\n\n        case 'characterClassRange':\n          var min = item.min.codePoint;\n          var max = item.max.codePoint;\n          set.addRange(min, max);\n\n          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n            set.iuAddRange(min, max);\n          }\n\n          break;\n\n        case 'characterClassEscape':\n          set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));\n          break;\n\n        case 'unicodePropertyEscape':\n          set.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n          break;\n        // The `default` clause is only here as a safeguard; it should never be\n        // reached. Code coverage tools should ignore it.\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"Unknown term type: \".concat(item.type));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (characterClassItem.negative) {\n    set = (config.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n  }\n\n  update(characterClassItem, set.toString(regenerateOptions));\n  return characterClassItem;\n};\n\nvar updateNamedReference = function updateNamedReference(item, index) {\n  delete item.name;\n  item.matchIndex = index;\n};\n\nvar assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {\n  var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(\"Unknown group names: \".concat(unmatchedReferencesNames));\n  }\n};\n\nvar processTerm = function processTerm(item, regenerateOptions, groups) {\n  switch (item.type) {\n    case 'dot':\n      update(item, getDotSet(config.unicode, config.dotAll).toString(regenerateOptions));\n      break;\n\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n\n    case 'unicodePropertyEscape':\n      update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));\n      break;\n\n    case 'characterClassEscape':\n      update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));\n      break;\n\n    case 'group':\n      groups.lastIndex++;\n\n      if (item.name) {\n        var name = item.name.value;\n\n        if (groups.names[name]) {\n          throw new Error(\"Multiple groups with the same name (\".concat(name, \") are not allowed.\"));\n        }\n\n        var index = groups.lastIndex;\n        delete item.name;\n        groups.names[name] = index;\n\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n\n        if (groups.unmatchedReferences[name]) {\n          groups.unmatchedReferences[name].forEach(function (reference) {\n            updateNamedReference(reference, index);\n          });\n          delete groups.unmatchedReferences[name];\n        }\n      }\n\n    /* falls through */\n\n    case 'alternative':\n    case 'disjunction':\n    case 'quantifier':\n      item.body = item.body.map(function (term) {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n\n    case 'value':\n      var codePoint = item.codePoint;\n      var set = regenerate(codePoint);\n\n      if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n        var folded = caseFold(codePoint);\n\n        if (folded) {\n          set.add(folded);\n        }\n      }\n\n      update(item, set.toString(regenerateOptions));\n      break;\n\n    case 'reference':\n      if (item.name) {\n        var _name = item.name.value;\n        var _index = groups.names[_name];\n\n        if (_index) {\n          updateNamedReference(item, _index);\n          break;\n        }\n\n        if (!groups.unmatchedReferences[_name]) {\n          groups.unmatchedReferences[_name] = [];\n        } // Keep track of references used before the corresponding group.\n\n\n        groups.unmatchedReferences[_name].push(item);\n      }\n\n      break;\n\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(\"Unknown term type: \".concat(item.type));\n  }\n\n  return item;\n};\n\nvar config = {\n  'ignoreCase': false,\n  'unicode': false,\n  'dotAll': false,\n  'useUnicodeFlag': false\n};\n\nvar rewritePattern = function rewritePattern(pattern, flags, options) {\n  var regjsparserFeatures = {\n    'unicodePropertyEscape': options && options.unicodePropertyEscape,\n    'namedGroups': options && options.namedGroup,\n    'lookbehind': options && options.lookbehind\n  };\n  config.ignoreCase = flags && flags.includes('i');\n  config.unicode = flags && flags.includes('u');\n  var supportDotAllFlag = options && options.dotAllFlag;\n  config.dotAll = supportDotAllFlag && flags && flags.includes('s');\n  config.useUnicodeFlag = options && options.useUnicodeFlag;\n  var regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.unicode\n  };\n  var groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: index }\n    'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\n  };\n  var tree = parse(pattern, flags, regjsparserFeatures); // Note: `processTerm` mutates `tree` and `groups`.\n\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\n\nmodule.exports = rewritePattern;","map":{"version":3,"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","UNICODE_SET","addRange","BMP_SET","DOT_SET_UNICODE","clone","remove","DOT_SET","intersection","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","prototype","iuAddRange","min","max","$this","folded","caseFold","add","update","item","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","processCharacterClass","characterClassItem","regenerateOptions","body","negative","toString","updateNamedReference","index","name","matchIndex","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","lastIndex","names","onNamedGroup","call","forEach","reference","map","term","push","rewritePattern","flags","options","regjsparserFeatures","unicodePropertyEscape","namedGroup","lookbehind","includes","supportDotAllFlag","dotAllFlag","create","module","exports"],"sources":["/Users/sabrinabongiovanni/my-app/node_modules/regexpu-core/rewrite-pattern.js"],"sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n// Without the `u` flag, the range stops at 0xFFFF.\n// https://mths.be/es6#sec-pattern-semantics\nconst BMP_SET = regenerate().addRange(0x0, 0xFFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./` (only BMP code points).\nconst DOT_SET = DOT_SET_UNICODE.clone()\n\t.intersection(BMP_SET);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getDotSet = (unicode, dotAll) => {\n\tif (dotAll) {\n\t\treturn unicode ? UNICODE_SET : BMP_SET;\n\t}\n\treturn unicode ? DOT_SET_UNICODE : DOT_SET;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a binary\n\t// property. Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\treturn UNICODE_SET.clone().remove(set);\n\t}\n\treturn set.clone();\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst processCharacterClass = (characterClassItem, regenerateOptions) => {\n\tlet set = regenerate();\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tset.add(item.codePoint);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tconst folded = caseFold(item.codePoint);\n\t\t\t\t\tif (folded) {\n\t\t\t\t\t\tset.add(folded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\tset.addRange(min, max);\n\t\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\t\tset.iuAddRange(min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\tset.add(getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tset.add(getUnicodePropertyEscapeSet(item.value, item.negative));\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\t}\n\tif (characterClassItem.negative) {\n\t\tset = (config.unicode ? UNICODE_SET : BMP_SET).clone().remove(set);\n\t}\n\tupdate(characterClassItem, set.toString(regenerateOptions));\n\treturn characterClassItem;\n};\n\nconst updateNamedReference = (item, index) => {\n\tdelete item.name;\n\titem.matchIndex = index;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetDotSet(config.unicode, config.dotAll).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetUnicodePropertyEscapeSet(item.value, item.negative)\n\t\t\t\t\t.toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tupdate(\n\t\t\t\titem,\n\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.unicode,\n\t\t\t\t\tconfig.ignoreCase\n\t\t\t\t).toString(regenerateOptions)\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tgroups.lastIndex++;\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.names[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Multiple groups with the same name (${ name }) are not allowed.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tdelete item.name;\n\n\t\t\t\tgroups.names[name] = index;\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name].forEach(reference => {\n\t\t\t\t\t\tupdateNamedReference(reference, index);\n\t\t\t\t\t});\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'alternative':\n\t\tcase 'disjunction':\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst index = groups.names[name];\n\t\t\t\tif (index) {\n\t\t\t\t\tupdateNamedReference(item, index);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!groups.unmatchedReferences[name]) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = [];\n\t\t\t\t}\n\t\t\t\t// Keep track of references used before the corresponding group.\n\t\t\t\tgroups.unmatchedReferences[name].push(item);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'ignoreCase': false,\n\t'unicode': false,\n\t'dotAll': false,\n\t'useUnicodeFlag': false\n};\nconst rewritePattern = (pattern, flags, options) => {\n\tconst regjsparserFeatures = {\n\t\t'unicodePropertyEscape': options && options.unicodePropertyEscape,\n\t\t'namedGroups': options && options.namedGroup,\n\t\t'lookbehind': options && options.lookbehind\n\t};\n\tconfig.ignoreCase = flags && flags.includes('i');\n\tconfig.unicode = flags && flags.includes('u');\n\tconst supportDotAllFlag = options && options.dotAllFlag;\n\tconfig.dotAll = supportDotAllFlag && flags && flags.includes('s');\n\tconfig.useUnicodeFlag = options && options.useUnicodeFlag;\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.unicode\n\t};\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: index }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: Array<reference> }\n\t};\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}